#预处理器
##预处理阶段

```
在源代码编译之前对其进行一些文本性质的操作. 主要任务包括删除注释, 插入被#include指令包含的文件的内容,定义和替换由#define指令定义的符号以及确定代码的部分内容是否应该根据一些条件编译指令进行编译.
```
##预定义符号

```c
    printf("%s\n", __FILE__);
    printf("%d\n", __LINE__);
    printf("%s\n", __DATE__);
    printf("%s\n", __TIME__);
    /// 如果编译器遵循ANSI C 其值就为1 否则未定义
    printf("%d\n", __STDC__);
```

##define

```
#define name stuff
/// 每当有符号name出现在指令后面时, 预处理器就会把它替换成stuff.
```
##宏
`#define`机制包含了一个规定, 允许把参数替换到文本中去. 这种实现通常称为`宏`或`定义宏`
`defined macro`

```c
#define name(parameter-list) stuff
parameter-list(参数列表)是一个由逗号分隔的符号列表, 它们可能出现在stuff中.
```


```c
/// 所有用于对数值表达式进行求值的宏定义都应该用这种方式加上括号, 避免在使用宏时, 由于参数中的操作符或临近的操作符之间不可预料的相互作用

#define SQUARE(x) ((x)*(x))
```

```c
#define repeat do
#define until(x) while( !(x) )
repeat {
	putchar('a');
} until(i >= 10);
//// 替换
do {
	putchar('a');
} while (!( i>= 10));
    
```
## `##`
具有连接字符串的作用, 执行完A##B后变为AB

```
#define ADD_TO_SUM( sum_number, value ) \
        sum ## sum_number += value

   int sum4 = 0;
   ADD_TO_SUM(4, 11); /// 输出11 
```

##define替换
在程序中推展`#define`定义符号和宏时, 需要涉及几个步骤.
1. 在调用宏时, 首先对参数进行检查, 看看是否包含了任何由`#define`定义的符号.如果是, 它们首先被替换.
2. 替换文本随后被插入到程序中原来的位置,对于宏,参数名被他们的值所替代.

##带副作用的宏参数
副作用就是在表达式求值时出现的永久性效果.

`奇偶校验`是一种错误检测机制. 在数据被存储或通过通信线路传送之前, 为一个值计算(并添加)一个校验位,使数据的二进制模式中1的个数为偶数. 以后, 数据可以通过计算它的位1的个数来验证其有效性.

##命名约定
常见的名字是将宏名字全部大写
![](https://ws4.sinaimg.cn/large/006tKfTcgy1fqz44uhry0j30op09zq4w.jpg)

##undef
如果一个现存的名字需要被重新定义, 那么它的旧定义首先必须用`#undef`移除

##条件编译
使用条件编译你可以选择代码的一部分是被正常编译还是完全忽略.

```
#if DEBUG
#elif condition
#elif condition
#endif

```
函数库头文件 还是 本地头文件

##其他指令

#progma指令是另一种机制, 用于支持因编译器而异的特性.

最后 无效指令(null directive)就是一个以`#`符号开头, 但后面不跟任何内容的一行.

宏就是一个被定义的序列,它的参数值将被替换. 当一个宏被调用时, 它的每个参数都被一个具体的值替换.
有些任务既可以用宏也可以用函数实现, 但是, 宏与类型无关. 宏的指执行速度快于函数,因为它不存在函数调用/返回的开销.

##总结

不要在一个宏定义的末尾加上分号, 使其成为一条完整的语句.
在宏定义中使用参数,但是忘了在它们周围加上括号.
忘了在整个宏定义的两边加上括号
嵌套的`#include`文件使我们很难判断源文件之间的依赖关系.

###输入输出函数

[https://www.lee1994.com/]


